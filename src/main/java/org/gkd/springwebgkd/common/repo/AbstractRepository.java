/*
 * Created on 22 Des 2015 ( Date ISO 2015-12-22 - Time 13:48:50 )
 * Generated by Telosys Tools Generator ( version 2.1.1 )
 */
package org.gkd.springwebgkd.common.repo;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.persistence.EntityManager;
import javax.persistence.EntityNotFoundException;
import javax.persistence.PersistenceException;
import javax.persistence.Query;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;


/**
 * Generic JPA service operations <br>
 * Provided by Telosys Tools for JPA testing
 * 
 * @param <T>
 *            Entity type
 * @param <PK>
 *            Primary key type
 */
@SuppressWarnings("unchecked")
public abstract class AbstractRepository<T, PK extends java.io.Serializable> {


	private static final Predicate[] VOID_PREDICATE_ARRAY = {};

	/**
	 * The class of the entity managed by the concrete service
	 */
	private final Class<T> persistentClass;

	protected abstract EntityManager getEntityManager();

	/**
	 * Constructor
	 * 
	 * @param persistentClass
	 */
	public AbstractRepository(final Class<T> persistentClass) {
		this.persistentClass = persistentClass;
	}

	/**
	 * Find entity by Primary Key
	 * 
	 * @param primaryKey
	 * @return
	 */
	public T load(final PK primaryKey) {

		EntityManager em = getEntityManager();
		try {
			return (T) em.find(persistentClass, primaryKey);
		} catch (PersistenceException ex) {
			ex.printStackTrace();
			return null;
		} finally {
			em.close();
		}
	}

	/**
	 * Load all entities
	 * 
	 * @param <T>
	 * @param query
	 * @return
	 */
	public List<T> loadAll() {
		return findEntities(true, -1, -1);
	}

	/**
	 *
	 * @param maxResults
	 * @param firstResult
	 * @return
	 */
	public List<T> findEntities(int maxResults, int firstResult) {
		return findEntities(false, maxResults, firstResult);
	}

	/**
	 *
	 * @param all
	 * @param maxResults
	 * @param firstResult
	 * @return
	 */
	private List<T> findEntities(boolean all, int maxResults, int firstResult) {
		EntityManager em = getEntityManager();
		try {
			CriteriaQuery<T> cq = (CriteriaQuery<T>) em.getCriteriaBuilder().createQuery();
			cq.select(cq.from(persistentClass));
			Query q = em.createQuery(cq);
			if (!all) {
				q.setMaxResults(maxResults);
				q.setFirstResult(firstResult);
			}
			return q.getResultList();
		} finally {
			em.close();
		}
	}

	/**
	 * Load a list of entities using a named query without parameter
	 * 
	 * @param queryName
	 * @return
	 */
	public List<T> loadByNamedQuery(final String queryName) {
		EntityManager em = getEntityManager();
		try {
			final Query query = em.createNamedQuery(queryName);
			return query.getResultList();

			// JPA operation execution
		} finally {
			em.close();
		}
	}

	/**
	 * Load a list of entities using a named query with parameters
	 * 
	 * @param queryName
	 * @param queryParameters
	 * @return
	 */
	public List<T> loadByNamedQuery(final String queryName, final Map<String, Object> queryParameters) {

		EntityManager em = getEntityManager();
		try {
			final Query query = em.createNamedQuery(queryName);
			final Iterator<String> i = queryParameters.keySet().iterator();
			while (i.hasNext()) {
				String key = i.next();
				query.setParameter(key, queryParameters.get(key));
			}
			return query.getResultList();
		} finally {
			em.close();
		}
		// JPA operation execution

	}

	/**
	 * Insert entity ( TRANSACTIONAL )
	 * 
	 * @param <T>
	 * @return
	 */
	public T save(final T entity) throws PersistenceException {
		
		EntityManager em = getEntityManager();
			try {
				// Execute application JPA operation with the current EntityManager
				em.persist(entity);
				
				
			
		} finally {
			// Ensure EntityManager is closed 
			em.close();
		}
		
		return entity;
	}

	/**
	 * Save the given entity ( TRANSACTIONAL )
	 * 
	 * @param <T>
	 * @param entity
	 * @return
	 */
	public T edit(final T entity) {
		EntityManager em = getEntityManager();
		try {
			// Execute application JPA operation with the current EntityManager
			em.merge(entity);
			
			
		
	} finally {
		// Ensure EntityManager is closed 
		em.close();
	}
	
	return entity;
	}

	/**
	 * Delete entity by primary key ( TRANSACTIONAL )
	 * 
	 * @param primaryKey
	 */
	public boolean delete(T entity, final PK primaryKey) {
		
		EntityManager em = null;
		try {
			em = getEntityManager();

			try {
				entity = em.getReference(persistentClass, primaryKey);
			} catch (EntityNotFoundException enfe) {

				enfe.printStackTrace();

				return Boolean.FALSE;
			}
			em.remove(primaryKey);
			return Boolean.TRUE;
		} finally {
			if (em != null) {
				em.close();
			}
		}

	}

	/**
	 * Search entities using the given query parameters <br>
	 * Returns all the entities if no query parameter
	 * 
	 * @param queryParameters
	 *            the query parameters to be used (can be null )
	 * @return
	 */
	public List<T> search(final Map<String, Object> queryParameters, String orderBy, int maxResult) {
		if (queryParameters != null) {
			return this.searchWithParameters(queryParameters, orderBy, maxResult);
		} else {
			return this.loadAll();
		}
	}

	/**
	 * Search entities using given query parameters
	 * 
	 * @param queryParameters
	 *            the query parameters to be used (cannot be null )
	 * @return
	 */
	private List<T> searchWithParameters(final Map<String, Object> queryParameters, String orderBy, int maxResult) {
		EntityManager em = null;
		try {
			em = getEntityManager();
			CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
			CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(persistentClass);
			Root<T> from = criteriaQuery.from(persistentClass);

			List<Predicate> predicates = new ArrayList<Predicate>();

			for (Map.Entry<String, Object> e : queryParameters.entrySet()) {
				String expression = e.getKey();
				Object value = e.getValue();

				System.out.println("=== Criterion : " + expression + " : " + value);

				if (value != null) {
					boolean operatorFound = false;
					int i = expression.indexOf(' ');
					if (i >= 0) {
						String name = expression.substring(0, i);
						String oper = expression.substring(i, expression.length()).trim();
						System.out.println("name = '" + name + "'   oper = '" + oper + "'  value = '" + value + "'");
						if (oper.length() > 0) {
							operatorFound = true;
							if (value instanceof String) {
								String strValue = (String) value;
								if ("=".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.equal(from.get(name), strValue);
									predicates.add(p);
								} else if ("!=".equalsIgnoreCase(oper) || "<>".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.notEqual(from.get(name), strValue);
									predicates.add(p);
								} else if ("like".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.like(from.<String> get(name), strValue);
									predicates.add(p);
								} else {
									throw new RuntimeException(
											"Search : invalid operator '" + oper + "' for String attribute");
								}
							} else if (value instanceof Number) {
								Number numValue = (Number) value;
								if ("=".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.equal(from.<Number> get(name), numValue);
									predicates.add(p);
								} else if ("!=".equalsIgnoreCase(oper) || "<>".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.notEqual(from.<Number> get(name), numValue);
									predicates.add(p);
								} else if (">".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.gt(from.<Number> get(name), numValue);
									predicates.add(p);
								} else if ("<".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.lt(from.<Number> get(name), numValue);
									predicates.add(p);
								} else if (">=".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.ge(from.<Number> get(name), numValue);
									predicates.add(p);
								} else if ("<=".equalsIgnoreCase(oper)) {
									Predicate p = criteriaBuilder.le(from.<Number> get(name), numValue);
									predicates.add(p);
								} else {
									throw new RuntimeException(
											"Search : invalid operator '" + oper + "' for Number attribute");
								}
							} else if (value instanceof Date) {
								if ("=".equalsIgnoreCase(oper)) {
									Date dtValue = (Date) value;
									SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd");
									
									Predicate p = criteriaBuilder.equal(criteriaBuilder.function("TO_CHAR", String.class,from.get(name), criteriaBuilder.literal("yyyyMMdd")), 
											formatter.format(dtValue) );
									predicates.add(p);
								} else {
									throw new RuntimeException("Search : invalid operator '" + oper + "' for Date attribute");
								}
							}
						}
					}
					if (!operatorFound) {
						predicates.add(criteriaBuilder.equal(from.get(expression), value));
					}
				} else {
					predicates.add(criteriaBuilder.isNull(from.get(expression)));
				}
			}

			criteriaQuery.where(predicates.toArray(VOID_PREDICATE_ARRAY));
			if(orderBy != null){
				int j = orderBy.indexOf(' ');
				String order = "";
				String sort = "";
				if (j >= 0) {
					order = orderBy.substring(0, j);
					sort = orderBy.substring(j, orderBy.length()).trim();
				}
				if ("asc".equalsIgnoreCase(sort)) {
					criteriaQuery.orderBy(criteriaBuilder.asc(from.get(order)));
				} else {
					criteriaQuery.orderBy(criteriaBuilder.desc(from.get(order)));
				}
				
			}

			TypedQuery<T> typedQuery = em.createQuery(criteriaQuery);
			
			if(maxResult > 0){
				typedQuery.setMaxResults(maxResult);
			}
			return typedQuery.getResultList();

		} finally {
			em.close();
		}
	}

}
